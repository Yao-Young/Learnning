背景：

​	在分页存储管理中，经编译连接处理得到一维地址结构的可装配目标木块，这是从0开始编址的单一连续逻辑地址空间，虽然可以把程序分成页面，但是页面与源程序并不存在逻辑关系，也就难以对源程序以模块为单位进行分配、共享和保护。事实上，程序更多是采用分段结构，应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每段都从0开始编址，有各自的名字和长度且实现不同功能。



分段存储管理基本原理

分段存储管理把进程的逻辑地址空间分成多端，提供如下形成的二维逻辑地址：

![1654950765938](assets\1654950765938.png)

在分页存储管理中，页的划分(即逻辑地址分为<页号，页内位移>)是用户不可见的，连续的地址空间将根据页面的大小自动分页；而在分段存储管理中，地址结构是用户可见的，用户知道逻辑地址如何划分为段和段内位移，在设计程序时段的最大长度由地址结构规定，程序中所允许的最多段数会受到限制。例如：段号为16位，段内偏移量为16位，因此一个作业最多有$2^{16}=65536$段，最短段长为${64KB}$.

分段存储管理的实现基于可变分区存储管理原理，分段方法是以段为单位来划分和连续存放，为作业的各段分配一个连续内存空间，而个段之间不一定连续。



段表：

![1654951567920](assets\1654951567920.png)

在进行存储分配时，每个进程都有一张逻辑地址与物理地址映射的段表，它指出内存中各分段的段号、段起始地址和段长度。在撤销进程时，回收所占用的内存空间，并清除此进程的段表。

![1654951763065](assets\1654951763065.png)

地址转换：

![1654951989281](assets\1654951989281.png)

1、从逻辑地址中取出**段号**，将其与段表寄存器中的段表长度进行比较，判断是否越界(s >= m)，不越界继续执行

2、找到段号对应的**段表项地址 = 段表始址 + 段号 * 段表项长度**，得到段长和基址，判断偏移量是否超出段长(>=)，不越界继续执行

3、取出基址，计算**物理地址 = 基址 + 位移**，用得到的物理地址去访问内存 



段的共享和保护

与分页共享类似，若多个进程段表中的某段指向内存相同地址，内存中以该处为起始地址的某段便可被共享。为了方便共享，系统常建立一章共享段表用来记录所有共享段，内容包括段名、共享计数、段长、段首址、保护位等。当多个进程共享同一段时，这些进程的段表中的表项指向共享段中的同一表目。保护位用来对共享段实施保护，如禁写、禁修改等。

段的保护方法主要有两种：存取控制保护和地址越界保护。地址越界保护将段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度，则产生越界中断；再将段表项中的段长和逻辑地址中的段内偏移量进行比较，若段内偏移量大于段长，也会产生越界中断。分页管理只需要判断页号是否越界，页内偏移量是不可能越界的。

与分页管理不同，段式管理不能通过给出任何一个整数便可以确定对应的物理地址，因为每段的长度是不固定的，无法通过整数触发得出段号，无法通过求余得出段内偏移，所以端号和段内偏移一定要显示给出(<段号，段内偏移>)因此分段管理的地址空间是二维的。

