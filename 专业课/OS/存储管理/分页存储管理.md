# 分页存储管理

[TOC]

## 一、分页储存管理基本原理

背景：

​	采用连续存储管理方式，会导致内存"碎片"的出现，而且有时为了接纳新作业，往往需要移动已在内存的信息，这样不仅不方便，而且处理器开销太大。采用分页存储管理允许程序存放到若干不相邻的空闲块中，即可免除移动信息工作，又可充分利用内存空间，消除动态分区法中的"碎片"问题，从而提高内存空间利用率

​	**分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为内存的基本单位。每个进程也以块为基本单位进行划分，进程在执行时，以块为单位逐个申请内存中的块空间**

### 1.	基本概念

- 页面	

  进程**逻辑地址空间**分成相等的区，每个区称为页面或页，页号从0开始一次编号

- 页框

  页框又称页帧，把**内存物理地址空间**分成大小相等的区，其大小与页面大小相等，每个区是一个页框(物理块)，块号从0开始依次编号

- 逻辑地址

  **分页储存器的逻辑地址由 页号 和 页内位移 两部分组成**

  ![1651802314915](assets\1651802314915.png)

  计算机地址总线通常是32位，页面尺寸若规定位12位(页长4KB)，那么页号共20位，表示地址空间最多包含$2^{20}$个页面

- 内存页框表

  **该表长度取决于内存划分的物理块数，编号可与物理块号一致，页框表的表项给出物理块使用情况：0为空闲，1为占用。有的系统还会增加保护位。**

- 页表

  - 背景：

  		在进行内存分配时以页框为单位，进程的信息有多少页，那么把它装入内存时就分配多少页框，虽然进程的逻辑地址划分成编号连续的页面，但被装入内存后的相应页框未必紧邻，即进程的信息按页面分散存放在内存不相邻的页框中

  - 思考：

  1、当进程的程序和数据被分散存放在内存中后，其页面与被分配的页框如何建立联系呢？

  2、逻辑地址(页面)如何转换成物理地址(页框)呢？

  3、进程被装入后的物理地址空间由连续变成分散后，如何保证程序正确执行呢？

  - 定义：

  ->出自《操作系统教程》洛斌

  **仍然采用动态地址重定位技术，让程序在执行时动态地进行地址转换，由于程序以页面为单位存储，所以为每个页面设立一个重定位寄存器，这些重定位寄存器的集合称为页表(page table)**

  类似于基址/限长寄存器，每个页面都有重定位寄存器，根据页的逻辑地址可以找到对一个页号的重定位寄存器，再加上页内位移就可以确定该页面的物理地址了

  ->出自《操作系统》汤小凤

  **在分页系统中，允许将进程的各个页面离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能够在内存中找到每个页面对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表，其中记录了相应页在内存中对应的物理块号，也就是说页表的作用是实现从页号到物理块号的地址映射**

  ->出自《计算机组成与设计》

  

  	页表是操作系统为进程建立的，是程序页面和内存页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框之间的对应关系。使用页表的目的是把页面映射为页框，通过页表可以把逻辑地址中的逻辑页面替换成物理地址中的页框域。
  	
  	为了减少系统开销，不用硬件而是在内存中开辟存储区以存放进程页表，系统另设置专用硬件——页表基址寄存器，存放当前运行进程的页表起始地址，以加快地址转换速度。

```
总的来说，进程所有的 逻辑地址<页号，偏移量>，内存划分为<页框，物理块>，为了将进程逻辑地址翻译成物理地址，我们需要辅助工具，来记录进程的页号和内存的页框之间的映射关系，这个关系集合就是页表。

	采用分页存储管理时，逻辑地址是连续的，用户在编址程序时，仍使用相对地址，不必考虑如何分页，由硬件地址转换机构和操作系统的管理需要来决定页面大小，从而确定内存分块大小。进程在内存中的每个页框内的地址是连续的，但是页框之间的地址可以不连续，进程映像在内存的存放地址由连续到离散的变化为虚拟存储器的实现奠定了基础。
```

- 地址转换(分页的重定位)

  ![1651841588126](assets\1651841588126.png)

  1）当进程被调度执行时，将页表起始地址和页表长度装入页表寄存器。

  2）获取逻辑地址<页号，页内地址偏移量>

  3）比较页号和页表长度，如果页号 大于等于 页表长度 则产生越界中断，否则继续执行

  4）页表中页号对应的页表项地址 = 页表始址 + 页号 * 页表项长度，得到物理块号

  5）物理地址 = 物理块号 * 页框大小 + 偏移量

## 二、快表

背景：

​	页表可以放在一组寄存器中，地址转换时只要从相应寄存器中取值就可以得到页框号，但是硬件代价太高；若页表也存放在内存中，按照给定逻辑地址进行读写操作时，至少访问内存两次:第一次访问页表，第二次根据所得物理地址进行存取数据或指令，这种方法比通常执行指令的速度慢了一半，显然我们想要加快第一次的访问速度。

​	为了提高运算速度，在硬件中设置相联存储器，具有并行查找能力的高速缓冲器——快表(TLB)，用来存放当前访问的部分页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。

具有快表的分页机制中，地址的变换过程如下：

1）CPU给出逻辑地址，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较

2）若找到匹配的页号，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。

3）若未找到匹配的页号，则需要访问主存中的页表，读取页表项，同时将其存入快表。若快表已满，则须按特定的算法淘汰一个旧页表项。

## 三、访问内存的有效时间

​	**从进程发出指定逻辑地址的访问请求，经过地址转换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间(Effective Access Time, EAT)。**

设依次访问内存的时间为t

1	在基本分页存储管理方式中，EAT为两次内存访问时间之和：

​	$EAT = t + t = 2t$

2	在引入快表的分页存储管理方式中，快表的命中率(使用快表并在其中成功查找到所需页面的表项的比率)

​	$EAT = a * β + (t + β) (1 - a) + t = 2t + β - t * a$

β-访问快表的时间，a-命中率，t-访问一次内存的时间。由于β肯定小于t，当命中率提高时，EAT也随之减小。	

## 三、分页储存空间的分配和回收

分页存储管理中，系统要建立一张内存物理块表，用来记录页框状态，管理内存物理块的分配，所包含的信息由内存总块数、哪些为空闲块、哪些已分配集分给哪个进程等，下图使用位示图和链表法。

![1651808184885](assets\1651808184885.png)

分页存储管理页框算法如下：

进行内存分配时，先查空闲块数能否满足用户进程的要求，若不能则令进程等待；若能则查位示图，找出为0的那些位，置占用标志，从空闲块数中减去本次占用块数，按所能找到的位的位置计算对应页框号，填入此进程的页表。进程执行结束归还内存时，根据归还的页框号计算出对应位在位示图中的位置，将占有标志清0，并将归还块数加入空闲块数中。

图(c)使内存分配的链表法，表中各项包含以下内容：

进程占用区(P)还是空闲区(H)、起始地址、长度和指向下一表项的指针。

## 四、分页存储空间页面共享和保护

### 1.	页面共享和保护

### 2.	运行时动态链接



## 五、二级和多级页表

面临的问题：

由于页表占据的空间并不小，而且在前述情况下，还要求在内存中是连续存储的，当有成千上万个进程在内存时，大量的内存空间被占据，但却没有用。



背景：

​	现代计算机普遍支持${2^{32} -2^{64}}$容量的逻辑地址空间，采用分页存储管理时页表相当大。以Linux系统为例，其运行的$Intel$ x86平台具有$32$位地址，规定页面$4KB(2^{12})$时，那么，$4GB(2^{32})$的逻辑地址空间由$1MB(2^{20})$个页组成，若每个页表项占用4个字节，则需要占用$4MB(2^{32})$连续内存空间存放页表，这还是一个进程的地址空间，对于地址空间位64位的系统来说，问题将变得更加复杂。为此，页表和页面一样也要进行分页，这就形成了多级页表概念

解决办法：

1）对于页表所需的内存空间，可采用离散分配方式，已解决难以找到一块连续的内存空间的问题

2）只将当前需要的部分页表项调入内存，其余的页表仍驻留在磁盘上，需要时再调入

###1、二级页表

先解决1)

因为要将页表进行离散存储，并且能通过逻辑地址找到对应的物理地址，采取的策略如下：

把整个页表分割成许多小页表，每个称为页表页，它的大小与页框长度相同，于是每个页表页含有若干个页表表项。页表页从0开始顺序编号，允许被分散存放在不连续的页框中，为了找到页表页，应建立地址索引，称为页目录表，其表项指出页表页起始地址。系统位每个进程创建一张页表目录表，它的每个表项指出一个页表页，从而页表页的每个表项给出页面和页框的对应关系，页目录表是一级页表，页表页是二级页表，共同构成二级页表机制。

![1651852562474](assets\1651852562474.png)

```
1)由硬件"页目录表基址寄存器"指出当前运行进程的页目录表的内存起始地址start
2)加上"页目录位移"作为索引，可找到页表页在内存的起始地址
3）再以"页表页位移"作为索引，找到页表页的表项，此表项中包含一个页面对应的页框号，由"页框号"和"页内位移"便可生成物理地址
```

上诉方法能够解决分散存放页表页问题，并未解决页表也如何占用内存空间问题，解决方法如下：

进程运行涉及页面的页表页应存放在内存，而其他页表页使用时动态调入，为此，需要在页目录表中增加标志位，指示对应页表页是否已调入内存，地址转换机制根据逻辑地址中的"页目录位移"来查页目录表对应表项的标志位，如未调入，应产生"缺页表页"异常信号，请求操作系统将页表页调入内存。

```
简而言之，关于页表页的内存占用问题，需要的时才调入内存
```

二级页表地址转换需要三次访问内存，一次访问目录、一次访问页表页、一次访问指令或数据。随着64位地址的出现，二级页表仍不够用，所以三级、四级页表也已被引入系统。多级页表结构的本质是多级不连续，导致多级索引。以二级页表结构为例，应用程序的页面不连续存放，需要有页面地址索引，此索引就是进程页表。由于进程页表是不连续存放的多个页表页，故这些页表页也需要页表页地址索引，此索引就是页目录，这就形成二级索引，页目录项是页表页的索引，而页表页是程序页面的索引。

## 六、反置页表

```
重点：
1、什么是分页存储管理
2、为什么要分页存储管理
3、分页存储管理是如何工作的？核心是什么？
4、分页存储管理有什么优缺点？又是如何改进的？

上面假设计算机系统 有办法对一个进程进行离散的内存分配，在此基础上，我们再考虑要解决的问题：
	1、地址转换
	2、资源共享
	3、存储保护
	4、优化
	
```



Q1：什么是页表，给出一个具体的定义？

