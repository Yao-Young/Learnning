#连续存储管理

[TOC]

​	

​	**连续分配方式是指为一个用户程序分配一个连续的内存空间，譬如某用户需要100MB的内存空间，连续分配方式就在内存空间中为用户分配一块连续的100MB空间。**

##一、固定分区存储管理

​	**静态分区模式，基本思想是：内存空间被划分成数目固定不变的分区，各个分区大小不等，每个分区只装入一个作业，若多个分区中都装由作业，则它们可以并发执行，这是支持多道程序设计最简单的存储管理技术**

为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。

![1651750614370](assets\1651750614370.png)

关注的问题：

1、何时及如何把内存空间划分为分区？

系统初启时，管理员根据当天作业情况把内存划分成大小不等且数目固定的分区

2、作业进入分区的策略

- 方式一

  **每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个能够装入它的最小分区的进程等待队列尾部，当分区空闲时，就装入进程执行**

- 方式二

  **所有等待处理的作业排成一个等待队列，每当有分区空闲时，就从队首起依次搜索分区长度能容纳的作业以便装入执行**

评价：

```
方式一：
	可使装入分区浪费的空间最小，但如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌
方式二：
	改善了方式一的缺点，但是可能会有小作业占用大分区的情况，所以可以搜索分区长度所能容纳的最大作业装入执行
```



小结：

​	一、固定分区解决了单道程序运行在并发环境下不能与CPU速度匹配的问题，同时解决了单道程序运行时内存空间利用率低的问题，实现简单，适合于程序大小和出现频率已知的情形。

​	二、但还是有如下的缺点：

​	1）由于预先规定好分区大小，使得超出最大分区大小的作业无法装入，从而需要采用覆盖等技术来补救。

​	2）内存空间利用率不高，作业很少会恰好填满分区，容易产生分区内的空闲的"碎片"。

​	3）很难给一个作业进行动态扩充内存空间。

​	4）分区数目是在系统初启时确定的，这会限制多道运行程序的道数，不适合分时系统交互型用户及内存 

​              需求变化很大的情形。



##二、可变分区存储管理

**基本思想：按照作业大小来划分分区，但划分的时间、大小、位置都是动态的**

###1、可变分区内存空间的分配和回收

![1651728341067](assets\1651728341067.png)

​	在可变分区模式下，系统初启且用户作业尚未装入内存之前，整个用户区是一个大空闲分区，随着作业的装入和撤离，内存空间被分成许多分区(空闲 or 忙碌)

####数据结构

​	为了方便分配和回收，用于管理的数据结构可由两张表组成：已分配分区表和空闲分区表（链表或数组)

```
freelist -> <start_add, length>
busylist -> <start_add, length, pid>
```

####申请内存空间

​	当装入新的作业时，从空闲分区表中找出一个足够容纳它的空闲分区，将此分区分成两部分，一部分用来装入作业，称为已分配区；另一部分仍是空闲分区(若有)。这时，应往已分配分区表中添加新的记录，同时修改空闲分区表

####回收内存空间

当作业X撤离时，回收情况有如下4中情况：

![1651728377175](assets\1651728377175.png)

- X邻近都有作业(A和B)
- X一边有作业(A或B)
- X两边均为空闲区



###2、分配策略

​	以方便空闲区的查找和回收，将表内的数据进行排序，为了提高内存利用效率，常用的可变分区分配算法有一下5种：

​	1、最先/首次 适应(first fit)

```c
空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业
```

​	2、下次/邻近/循环首次 适应(next fit)

```c
由first fit算法演变而成，不同之处在于，分配内存时从上次查找借宿的位置开始继续查找
```

​	3、最优/最佳 适应(best fir)

```c
空闲分区按容量递增的次序链接，找到第一个能满足要求的，即最小的空闲分区分配给作业
```

​	4、最坏适应(worst fit)

```c
空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的空闲分区，从中割一部分存储空间给作业
```

​	5、快速适应(quick fit)

```c
为那些经常用到的长度的空闲区设立单独的空闲区链表。
```



克服了固定分区内存资源的浪费问题，有利于多道程序设计，提高内存资源利用率。

##三、地址转换和存储保护

1、对固定分区采用静态地址重定位，进程运行是使用绝对地址，可由加载程序进行地址越界检查。

2、对可变分区则采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件设置两个专用控制寄存

​      器：基址寄存器和限长寄存器。

```
基址寄存器存放分配给进程使用的分区的起始地址
限长寄存器存放进程所占用的连续存储空间的长度。
```

**当进程占有CPU运行后，操作系统可把分区地址 和 长度送入基址寄存器和限长寄存器，在执行指令或访问数据时，由硬件根据基址寄存器进行地址转换得到绝对地址，当逻辑地址小于限长值时，逻辑地址加上基址寄存器的值就可获得绝对地址；当逻辑地址大于限长值时，表示进程所访问的地址超出所分得的区域，此时不允许访问，已到达存储保护的目的。**

​	在多道程序系统种，硬件只需设置一对基址/限长寄存器，一个进程在执行过程种出现等待时间时，操作系统把基址/限长寄存器的内容随同此进程的其他信息，如PSW、通用寄存器等一起保护起来，另一个进程被选中执行时，则将其基址/限长值再送入基址/限长寄存器。

​	如果每个进程只能占用一个分区，则不允许各个进程之间有公共区域，这样当多个进程共享例行程序时就只好在各自内存存放一套副本，从而使内存利用率低。提供两对或多对基址/限长寄存器的机器中，允许一个进程占用两个或多个分区。可规定某对基址/限长寄存器的区域是共享的，用来存放共享的程序和数据，当然，共享区域中的信息必须为只读状态，于是多个用户进程共享的例行程序就可放在限定的公共区域中，让进程的共享部分取相同的基址/限长值

![1651757074603](assets\1651757074603.png)

##四、内存不足的存储管理技术

###1.	移动技术

​	**在可变分区法中，必须把进程装入一个连续的内存区域中，随着进程不断地装入和撤离，导致内存中常常出现分散的小空闲分区，称之为"碎片"。这可能导致，对于一个新来的作业，空闲分区表找不到合适的分区进行分配，但是空闲分区表中的分区("碎片")大小总和却大于作业所需的内存大小**

​	移动技术把已在内存中的进程分区连到一起，使分散的空闲区汇集成片，也叫内存紧凑

方法一：

```
把所有当前占用的分区内容移动到内存的一段
```

方法二：

```
把占用分区内容移动到内存的一段，但当产生足够大小的空闲区时就停止移动
```
![1651757697546](assets\1651757697546.png)

假设进程A请求分配$x$KB内存区，采用移动技术分配内存空间的算法如下：

```
1)查内存分配表，若有大于xKB的空闲区，则转4)
2)若空闲区总和小于xKB，则令进程A等待资源
3)移动内存的相关信息，修改内存分配表有关项，修改被移动的基址寄存器信息
4)分配xKB内存，修改内存分配表有关项，设置进程A的基址寄存器，有申请者等待给予释放，结束
```

###2、对换技术

​	**如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这中方式称为对换**

怎么换？

```
	当一个进程执行某些系统调用时编程阻塞态，这时存储管理程序会收到进程管理的通知，以巨顶是否将此进程的内存映像对换到磁盘；反之，当进程管理程序把已对换出去的进程转为就绪态时，会通知存储管理程序，一旦内存可用，立即把此进程对换回内存。
	由于硬件地址重定位寄存器的支持，对换进来的进程映像被复制到新分配的内存区域并重置重定位寄存器的值
	为了有效地实施对换，首先应该选择哪个进程换出。如果选择不当，将造成系统效率欠佳。通常系统把时间片耗尽或优先级较低的进程换出。
```

换什么？

```
对换应该将进程的哪些信息移出去呢？
	开始时，进程从执行文件被装入内存，其未修改部分(如代码)在内存与磁盘中始终一致，这些信息不必保存，当进程换回内存时，只需简单地从最初的可执行文件再加载依次。数据区和堆栈是进程运行时所创建和修改的，操作系统可通过文件系统把这些可变信息作为特俗文件保存。有些系统从降低开销角度考虑，开辟一块特俗磁盘区域作为对换空间，它包含连续的柱面和磁道，可通过磁盘读写实现高效访问
```

什么时候换？

```
	在批处理系统中，进程要求动态扩充内存空间且得不到满足时可触发对换；在分时系统中，对换可与调度结合，每个时间片结束或执行I/O操作时实施，调度程序启动一个挪出的进程换入，这样，轮到它执行时立即可以启动，对换进内存的进程其内存位置未必还在换出之前的位置上，所以需要解决对换过程中地址重定位问题。
	假设一个被对换的进程映像占用k个磁盘块，那么，一次进程对换的所有开销是2k个磁盘块I/O的时间，再加上进程重新申请内存资源所造成的时间延迟
```



​	广泛用于分时系统的调度中，以解决内存容量不足问题，使分时用户获得快速相应时间；也可用于批处理系统，以平衡系统负载。

​	对换比移动技术更有效，移动不能保证得到一个满足请求的空闲区，而利用对换技术总可按需挪出若干驻留的阻塞进程，且对换仅涉及少量进程，只需更少的内存访问。与移动不同的是，对换要访问磁盘，这是一个I/O集中型操作，会影响对用户的响应时间，但系统可让对换与计算型进程并行工作，不会造成系统性能的显著下降



###3、覆盖技术

​	**移动和对换技术解决因多个程序存在而导致内存不足问题，这种内存短缺只是暂时的；如果程序长度超出物理内存总和，或超出固定分区大小，则出现内存永久性短缺，大程序无法运行，前述两种方法无能为力，解决的一种方法是采用覆盖技术**

​	覆盖是指程序执行过程中程序的不同模块在内存中相互替代，以达到小内存执行大程序的目的，基本的实现技术是：

​	把用户空间分成固定区和一个或多个覆盖区，把控制或不可覆盖部分放在固定区，其余按调用结构及相应的系统调用，当程序装入运行时依次调入覆盖区。



##总结

连续内存管理方式的基本思想，实现思路：固定分区和动态分区，以及其各自的优缺点和使用场合



上次

```
存储大概是怎样的，程序是如何在内存上执行的
这次是，讨论内存如何为程序分配内存空间

思想，实现，适用场景，缺点是什么，改进方案？
总的目的就是要，尽可能多地让cpu转起来，让内存忙碌起来
```

