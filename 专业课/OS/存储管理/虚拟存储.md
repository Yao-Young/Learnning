

## 一、虚存概述

背景

虚拟存储器

**在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理内存容量大得多的、可寻址的"内存存储器"**.实际上，虚存对用户隐蔽可用物理内存的容量和操作细节，虚存的容量与物理内存大小无关，而受限于计算机地址结构和磁盘容量。

如图虚拟存储器概念图，逻辑地址空间是程序员的编程空间，物理地址空间是程序的执行空间，虚拟地址空间等同于物理内存加部分硬盘区域所组成的存储空间。实现虚存的关键问题是：把程序编程和访问地址与内存物理地址分隔开来，用户无需知道内存工作方式，只需在逻辑地址空间中编程，大大方便了程序编写工作，系统负责内存分配和地址映射，把逻辑地址最终转换为物理地址

![1654956597142](assets\1654956597142.png)

进程不全装入内存时能够正确运行？局部性原理

虚存管理与对换计数的区别：

```
虽说都是在内存和磁盘之间的交换信息，但却存在很大区别。对换计数以进程为单位，档期所需内存空间大于当前系统的拥有量时，进程无法被对换进内存工作；而虚存管理以页或段为单位，即使进程所需内存空间大于当前系统拥有的内存总量仍然能正常运行，因为系统可将其他进程的一部分分页换出至磁盘。
```

虚存的实质是实现内存资源的时分复用，每次把应用程序的一部分装入内存运行，运行结束后被换出，再装入应用程序的另一部分到内存中运行。通过"部分装入，部分替换"置换功能，便实现了应用程序的各个部分分时地进入内存。



实现虚存必须要解决好的问题：

1、内存与外存(磁盘)统一管理问题

2、逻辑地址和物理地址转换问题

3、部分装入和部分替换问题

实现虚存要付出一定开销，其中包括管理地址转换的各种数据结构所用的存储开销、执行地址转换指令所花费的时间开销和内存与外存交换页或段的I/O开销等



虚存管理主要采用以下技术实现：

- 请求分页
- 请求分段
- 请求段页

## 二、请求分页虚拟存储管理

### 1、请求分页虚存管理的硬件支撑MMU

​	操作系统的存储管理依靠底层硬件支撑来完成任务，此硬件称为存储管理部件(MMU)，它提供**地址转换和存储保护功能并支持虚存管理和多任务管理**

​	MMU由一组集成电路芯片组成，**逻辑地址作为输入，物理地址作为输出**，直接送达总线，对内存单元进行寻址，其位置和功能如图a，内部执行过程如图b

![1654957792883](assets\1654957792883.png)

MMU主要功能如下：

- 管理硬件页表基址寄存器
- 分解逻辑地址
- 管理快表
- 访问页表
- 发出异常
- 管理特征位

### 2、请求分页虚存管理的基本原理

​	请求分页虚存管理是将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装进内存，仅装入当前使用页面，进程执行过程中访问到不在内存的页面时，再由系统自动调入，用得比较多的分页虚存管理是请求分页

​	**请求分页(demand paging)，当需要执行某条指令或使用某个数据而发现它们不在内存时产生缺页异常(page fault)，系统从磁盘中把此指令或数据所在的页面装入，这样做能够保证用不到的页面不会被装入内存。**

如何发现页面不在内存中呢？

扩充页表项内容，增加驻留标志位以及用来跟踪页面使用情况和对页面实施保护及淘汰等所需的各种控制位，通常页表项至少包含以下信息。

![1654958335366](assets\1654958335366.png)

"引用位"：

```
在页面被引用即无论是读或写时设置，其值帮助系统进行页面淘汰
```

"修改位"

```
当页面被修改后硬件自动置位，一旦修改位被设置，此页被调出内存时必须先被写回磁盘
```

"保护位"

```
限定页面允许的访问权限(如读、写、执行等)
```

"内存块号"

```
页面对应的页框号，用于地址转换
```

"驻留标志位"

```
用来指出页面是否已装入内存。当访问一个页面时，如果某页的驻留标志位为1表示此页已在内存，可被正常访问；如果某页的驻留标志位为0，不能立即访问，产生缺页异常，存储管理根据磁盘地址将这个页面调入内存，然后重新启动相应指令。
```

那么，如何查找对应的磁盘地址呢？

磁盘的物理地址由磁盘机号、柱面号、磁头号和扇区号组成，通常规定扇区长度等于页面长度，页面与磁盘物理地址的对应表称为外页表，由操作系统管理。进程启动运行前系统为其建立外页表，并把进程页面装入外存，外页表也按进程页号顺序排列，所以查找外页表就找到页面对应的磁盘存放地址。为了节省内存空间，外页表可存放在磁盘中，当发生缺页异常需要查用时才被调入。



缺页异常

由于发现当前访问页面不在内存时由硬件所产生的一种特殊中断信号，是在只能够执行期间产生并由系统处理的。

可见，在请求分页虚存管理中，页表中存放的是逻辑地址换成物理地址时硬件需要的信息，其作用有：获得页框号以及实现虚实地址转换；设置各种访问控制位，对页面信息进行保护；设置各种标志位来实现相应的控制功能



使用快表且页表存放在内存的情况下，请求分页虚实地址转换过程：





### 3、交换区

​	在虚存系统中，当要访问的页面不存在内存时，就要将其装入，这能导致原本在内存中的页面被换出，而且被换出的页面可能在将来又要被换进内存，由于这种情况的存在，我们并不能简单地将被替换的页面丢掉。

### 4、页面装入策略和清除策略

### 5、页面分配策略

### 6、缺页中断率

### 7、全局页面替换策略

- **最佳页面替换**算法(Optimal replacement，OPT)

  当要调入一页而必须淘汰旧页时，应该淘汰以后不再访问的页，或距现在最长时间后才访问的页。这是一种很理想化的做法，但现实中不可能对程序的运行过程做出精确断言，所以这种做法通常用来做衡量各种具体算法的标准。

- **先进先出页面替换**算法(First-In First-Out replacement，FIFO)

  基于程序总是按线性顺序来访问物理空间这一假设，总是淘汰最先调入内存的页面，即淘汰在内存中驻留时间最长的页面。

  假如，采用请求分页调入页面，现有页面访问顺序：4，3，2，1，4，3，5，4，3，2，1，5。现在分配给进程的物理页框为3和和4个，其执行过程如下：

  ![1655017921626](assets\1655017921626.png)

  可以看到，页框数的增加在特殊情况下会造成更多的缺页异常

- 页面缓冲算法

  页面缓冲算法是对FIFO替换算法的一种改进，其策略为：系统维护两个FIFO队列——修改页面队列和非修改(空闲)页面队列，前者是由修改页面的页框所构成的链表；后者是由可直接用于装入页面的页框所构成的链表，只不过有些未修改的淘汰页暂时还留在其中，按照FIFO算法选出淘汰页，并不立即抛弃它，而是根据其内容是否被修改过而进入两个队列之一的末尾，需要装入的页面被读进非修改队列的队首所指向的页框中，不必等待淘汰页写回，使得进程能快速恢复运行。当选中的淘汰页被写回磁盘时，只需把此页占用的页框链接到非修改队列的末尾即可。每当修改页面队列中的页面达到一定数量时，将成批地写回磁盘，并把空闲页框加入非修改页面队列尾部。

- **最近最少使用页面替换**算法(Least Recently Used replacement，LRU)

  淘汰的页面是在最近一段时间内最久未被访问的那一页，它是基于程序局部型原理来考虑的，认为那些刚被使用过的页面可能还要立即被使用，而那些在较长时间内未被使用的页面可能不会立即被使用。

  为了能准确地淘汰最近使用的页面，必须维护一个特殊队列——页面淘汰队列，此队列存放当前在内存中的所有页号，每访问一页时就调整一次，使队列尾总是指向最近访问的页，队列头就是最近最少使用的页。

  - 引用位法

    

  - 计数法

  

  - 计时法

  

  - 老化算法

- **第二次机会页面替换**算法(Second Chance Replacement，SCR)

  FIFO算法会把经常使用的页面淘汰掉，为了避免这一点，可对算法进行改造，把FIFO算法与页表中的"引用位"结合起来使用，思路如下：首先检查FIFO页面队列中的对手，这是最早进入内存的页面，如果其"引用位"是0，那么，这个页面最早进入并且最长时间未被使用，选择此页面淘汰；如果其"引用位"是1，说明虽然它进入内存时间较早，但最近仍在使用，于是将其"引用位"清0，并把这个页面移至队尾，把它看做一个新调入的页，再给一次机会。简而言之，最先进入内存的页面如果最近还在被使用，仍然由机会像新调入页面一样留在内存中。特殊的情况如，内存中的页面都被访问过，即它们的"引用位"均为1，那么，第一遍检查将所有页面的"引用位"清0，第二遍找出队首，并把此页面淘汰，此时，SCR退化位FIFO

- **时钟页面替换**算法(Clock policy replacement，Clock)

  如果利用标准队列机制构造FIFO队列，SCR算法可能产生频繁的出队和入队，实现代价较高。作为SCR的一种改进，可采用循环

  

###8、局部页面替换算法

请求分页虚存管理的目标是找出当前进程访问的局部性所需要的页面，然后将这些页面加载到内存中，随着程序执行阶段的变化，从一个局部集转到另一个局部集，原来局部集的页面将从内存中卸载，包括新的局部集的页面会被加载到空出来的页框中。类似情况会出现在程序访问数据的不同部分，当某个给定的进程引起缺页时，不允许通过缩小其他进程的驻留页面集来解决问题。

```
简而言之，当某个进程的发生缺页时，系统不能将其他进程的页面调出，只能对这个进程的驻留页面集进行调整
```

- **局部最佳页面替换算法**(local Minimum replacement，MIN)

  与全局最佳替换算法类似，需要预知程序的页面引用串(该进程的页面调用顺序),再根据进程行为改变驻留页面数量。实现思想如下：

  进程在时刻t访问某页面，如果此页面不在内存中将导致一次缺页，把此页面装入一个空闲页框。无论发生缺页与否，算法在每一步都要考虑引用串，如果此页面在时间间隔$(t, t + \tau)$内未被再次引用，那么就移出；否则，此页面被保留在进程的驻留集中，直到再次被引用。($\tau$是一个系统常量，间隔$(t, t+\tau)$称为滑动窗口，窗口大小为$\tau + 1$)

  例如，进程页面引用串为：

  ![1655033206255](assets\1655033206255.png)

  在时刻t = 0，P4已被引用

  ![1655033255697](assets\1655033255697.png)

  ![1655034484797](assets\1655034484797.png)

  

- **工作集模型和工作集置换算法**(Working Set replacement，WS)

  工作集模型用来对局部最佳页面替换算法进行模拟实现，也是用滑动窗口概念，但并不向前查看页面引用串，而是基于程序局部性原理向后看，在任何给定时刻，一个进程不就的将来所需内存页框数可通过考查最近时间内的内存需求做出估计

  

  进程工作集指在某一段时间间隔内进程运行所需访问的页面集合，用$W(t, \Delta)$表示在时刻$t-\Delta$到时刻$t$之间所访问的页面集合，它就是进程在时刻$t$的工作集，变量$\Delta$为工作集窗口尺寸

  ![1655035090008](assets\1655035090008.png)

  ![1655035106388](assets\1655035106388.png)

  ![1655035177808](assets\1655035177808.png)

  工作集是程序局部性的近似表示，可以通过它来确定驻留集大小

  - 监视每个进程工作集，只有属于工作集的页面才能驻留在内存
  - 定期从进程驻留集中删去那些不在工作集中的页面
  - 仅当一个进程的工作集在内存时，进程才能执行。

- **模拟工作集替换算法**

  工作集策略在现实中监督驻留页面变化的开销很大，而且也很难估算一个合适的窗口$\Delta$的大小，为此介绍一种模拟工作集替换算法：

  为每个页面设置引用位及关联的时间戳，通过超时中断，至少每隔若干条指
  令就周期性地检查引用位及时间截,当发现引用位为1时，就将其置0 并把这次改变的时间作为时间戳记录下来。每当发现引用位为0时,通过系统当前时间诚去时间截的时间，计算出从上次使用以来末被再次访问的时间量,记作（0f。L_0f 值会随着每次超时中渐的处理而不渐增加，除非页面在此期间被再次引用，导致其引用位为 1。把t0ff 与系统时间參数1max 相比.若(off>tmax .就把页面从工作集中移出.释放相成页面并回收此页框。

  

- **缺页频率替换算法**(Page Fault Frequency replacement)

  这种算法根据连续的缺页之间的时间间隔来对缺页频率进行测量，每次缺页时
  利用测量时间调整进程工作集尺寸。其规则是：如果本次缺页与前次缺页之间的时间问隔超过临界值$\tau$，那么，在这个时问间隔内未引用的所有页面都被移出工作集。这就能保证进程工作集不会过分地扩大，与工作集模型相比,实现效率高，具在发生缺页异常时才调数页面,而不是每次引用时都需要调整。

  ![1655036417838](assets\1655036417838.png)

  

##三、请求分段式虚拟存储管理

##四、请求段页式虚拟存储管理

段式和分页的优缺点分析及相互结合

#### 1、基本原理

##五、小结

![1655037257758](assets\1655037257758.png)

![1655037275137](assets\1655037275137.png)

##六、实例分析

### 1、Linux虚拟存储管理

### 2、Intel的Pentium





## 七、参考链接

```
https://blog.csdn.net/shuxnhs/article/details/80956155
```







