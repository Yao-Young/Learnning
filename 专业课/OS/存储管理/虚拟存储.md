# 虚拟存储管理

[TOC]



## 一、虚存概述

背景

虚拟存储器

**在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理内存容量大得多的、可寻址的"内存存储器"**.实际上，虚存对用户隐蔽可用物理内存的容量和操作细节，虚存的容量与物理内存大小无关，而受限于计算机地址结构和磁盘容量。

如图虚拟存储器概念图，逻辑地址空间是程序员的编程空间，物理地址空间是程序的执行空间，虚拟地址空间等同于物理内存加部分硬盘区域所组成的存储空间。实现虚存的关键问题是：把程序编程和访问地址与内存物理地址分隔开来，用户无需知道内存工作方式，只需在逻辑地址空间中编程，大大方便了程序编写工作，系统负责内存分配和地址映射，把逻辑地址最终转换为物理地址

![1654956597142](./assets/1654956597142.png)

进程不全装入内存时能够正确运行？局部性原理

虚存管理与对换计数的区别：

```
虽说都是在内存和磁盘之间的交换信息，但却存在很大区别。对换计数以进程为单位，档期所需内存空间大于当前系统的拥有量时，进程无法被对换进内存工作；而虚存管理以页或段为单位，即使进程所需内存空间大于当前系统拥有的内存总量仍然能正常运行，因为系统可将其他进程的一部分分页换出至磁盘。
```

虚存的实质是实现内存资源的时分复用，每次把应用程序的一部分装入内存运行，运行结束后被换出，再装入应用程序的另一部分到内存中运行。通过"部分装入，部分替换"置换功能，便实现了应用程序的各个部分分时地进入内存。



实现虚存必须要解决好的问题：

1、内存与外存(磁盘)统一管理问题

2、逻辑地址和物理地址转换问题

3、部分装入和部分替换问题

实现虚存要付出一定开销，其中包括管理地址转换的各种数据结构所用的存储开销、执行地址转换指令所花费的时间开销和内存与外存交换页或段的I/O开销等



虚存管理主要采用以下技术实现：

- 请求分页
- 请求分段
- 请求段页

## 二、请求分页虚拟存储管理

### 1、请求分页虚存管理的硬件支撑MMU

​	操作系统的存储管理依靠底层硬件支撑来完成任务，此硬件称为存储管理部件(MMU)，它提供**地址转换和存储保护功能并支持虚存管理和多任务管理**

​	MMU由一组集成电路芯片组成，**逻辑地址作为输入，物理地址作为输出**，直接送达总线，对内存单元进行寻址，其位置和功能如图a，内部执行过程如图b

![1654957792883](./assets/1654957792883.png)

MMU主要功能如下：

- 管理硬件页表基址寄存器
- 分解逻辑地址
- 管理快表
- 访问页表
- 发出异常
- 管理特征位

### 2、请求分页虚存管理的基本原理

​	请求分页虚存管理是将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装进内存，仅装入当前使用页面，进程执行过程中访问到不在内存的页面时，再由系统自动调入，用得比较多的分页虚存管理是请求分页

​	**请求分页(demand paging)，当需要执行某条指令或使用某个数据而发现它们不在内存时产生缺页异常(page fault)，系统从磁盘中把此指令或数据所在的页面装入，这样做能够保证用不到的页面不会被装入内存。**

如何发现页面不在内存中呢？

扩充页表项内容，增加驻留标志位以及用来跟踪页面使用情况和对页面实施保护及淘汰等所需的各种控制位，通常页表项至少包含以下信息。

![1654958335366](./assets/1654958335366.png)

"引用位"：

```
在页面被引用即无论是读或写时设置，其值帮助系统进行页面淘汰
```

"修改位"

```
当页面被修改后硬件自动置位，一旦修改位被设置，此页被调出内存时必须先被写回磁盘
```

"保护位"

```
限定页面允许的访问权限(如读、写、执行等)
```

"内存块号"

```
页面对应的页框号，用于地址转换
```

"驻留标志位"

```
用来指出页面是否已装入内存。当访问一个页面时，如果某页的驻留标志位为1表示此页已在内存，可被正常访问；如果某页的驻留标志位为0，不能立即访问，产生缺页异常，存储管理根据磁盘地址将这个页面调入内存，然后重新启动相应指令。
```

那么，如何查找对应的磁盘地址呢？

磁盘的物理地址由磁盘机号、柱面号、磁头号和扇区号组成，通常规定扇区长度等于页面长度，页面与磁盘物理地址的对应表称为外页表，由操作系统管理。进程启动运行前系统为其建立外页表，并把进程页面装入外存，外页表也按进程页号顺序排列，所以查找外页表就找到页面对应的磁盘存放地址。为了节省内存空间，外页表可存放在磁盘中，当发生缺页异常需要查用时才被调入。



缺页异常

由于发现当前访问页面不在内存时由硬件所产生的一种特殊中断信号，是在只能够执行期间产生并由系统处理的。

可见，在请求分页虚存管理中，页表中存放的是逻辑地址换成物理地址时硬件需要的信息，其作用有：获得页框号以及实现虚实地址转换；设置各种访问控制位，对页面信息进行保护；设置各种标志位来实现相应的控制功能



使用快表且页表存放在内存的情况下，请求分页虚实地址转换过程：





### 3、交换区

​	在虚存系统中，当要访问的页面不存在内存时，就要将其装入，这能导致原本在内存中的页面被换出，而且被换出的页面可能在将来又要被换进内存，由于这种情况的存在，我们并不能简单地将被替换的页面丢掉。

### 4、页面装入策略和清除策略

- 请页式(demand paging)

  当产生缺页异常时调入页面

- 预调式(prepaging)

  依据某种算法动态预测进程最可能要访问的页面，尽量做到进程要访问的页面已经调入内存，且每次调入若干页面而不是仅调入一页

- 请页式清除

  仅当一页被选中进行替换且其内容被修改过才把它写回磁盘

- 预约式清除

  对于所有更改过的页面，在需要替换之前把它们都写回磁盘，可成批进行

### 5、页面分配策略

- 全局替换

  页面替换算法的作用范围是整个系统，不考虑进程属主

- 局部替换

  作用范围局限于进程自身

- 工作集

  为每个进程维护的一组页面，其大小随着进程的执行而变化，应自动排除不再在工作集中的页面。

### 6、缺页中断率

- 页面替换

  当内存空间已满而又要装入新页时，必须按照预定算法把已在内存中的页面写回。

- 抖动(thrashing)

  刚被淘汰的页面立即又要调用，而调入不就随即被淘汰，淘汰不就再被调入，如此往复，使得整个系统的页面调度非常频繁，以至大部分时间都花费在来回调度页面上，而不是执行计算任务

- 缺页中断率

  假定进程P共计n页，此进程分得页框m块(m, n均为正整数，且1<= m <= n)，即内存中最多能容纳进程的m页。如果进程P在运行中成功访问次数为S，不成功访问次数为F，则总的访问次数A = S + F，定义

  ​				$f = F / A$

  称$f$为缺页中断率，影响$f$的因素有：

  - 内存页框数：进程所分得得块数多，$f$低，反之$f$高
  - 页面大小：页面大$f$低，反之$f$高
  - 页面替换算法：取决于算法优劣
  - 程序特性：程序局部性要好

- 产生抖动的原因

  内存中同时运行的进程太多，而分配给每个进程的页框太少，不能满足它们正常运行的需要。由于出现频繁缺页异常，使得排队等待页面对换的进程数目剧增，从而使磁盘的有效时间大都花费在对换页面上，处理器的有效利用率大大降低，这时系统产生了抖动

- 解决抖动的方法：

  - 增加配给进程的页框数
  - 挑选页面替换算法
  - 改进应用程序结构

- 例子

  ![1655118958464](./assets/1655118958464.png)

  

### 7、全局页面替换策略

- **最佳页面替换**算法(Optimal replacement，OPT)

  当要调入一页而必须淘汰旧页时，应该淘汰**以后不再访问的页，或距现在最长时间后才访问的页**。

  ![1655121457829](./assets/1655121457829.png)



- **先进先出页面替换**算法(First-In First-Out replacement，FIFO)

  基于程序总是按线性顺序来访问物理空间这一假设，总是淘汰最先调入内存的页面，即淘汰在内存中驻留时间最长的页面。

  ![1655122249906](./assets/1655122249906.png)

  页面缓冲算法

  页面缓冲算法是对FIFO替换算法的一种改进，其策略为：系统维护两个FIFO队列——修改页面队列和非修改(空闲)页面队列，前者是由修改页面的页框所构成的链表；后者是由可直接用于装入页面的页框所构成的链表，只不过有些未修改的淘汰页暂时还留在其中，按照FIFO算法选出淘汰页，并不立即抛弃它，而是根据其内容是否被修改过而进入两个队列之一的末尾，需要装入的页面被读进非修改队列的队首所指向的页框中，不必等待淘汰页写回，使得进程能快速恢复运行。当选中的淘汰页被写回磁盘时，只需把此页占用的页框链接到非修改队列的末尾即可。每当修改页面队列中的页面达到一定数量时，将成批地写回磁盘，并把空闲页框加入非修改页面队列尾部。

  

- **最近最少使用页面替换**算法(Least Recently Used replacement，LRU)

  淘汰的页面是**在最近一段时间内最久未被访问的那一页**，它是基于程序局部性原理来考虑的。

  为了能准确地淘汰最近使用的页面，必须维护一个特殊队列——页面淘汰队列，此队列存放当前在内存中的所有页号，每访问一页时就调整一次，使队列尾总是指向最近访问的页，队列头就是最近最少使用的页。

  （第一位表示页号，第二位表示离最近一次引用的距离）

  ![1655123298613](./assets/1655123298613.png)

  ```
  模拟实现的方法有：引用位法、计数法、计时法、老化算法
  都是每个时间t将进行计位处理，然后挑选调出
  ```

  

- **第二次机会页面替换**算法(Second Chance Replacement，SCR)

  FIFO算法会把经常使用的页面淘汰掉，为了避免这一点，把FIFO算法与页表中的"引用位"结合起来使用，思路如下：首先检查FIFO页面队列中的队首，如果其"引用位"是0，那么，这个页面最早进入并且最长时间未被使用，将其淘汰；如果其"引用位"是1，说明虽然它进入内存时间较早，但最近仍在使用，于是将其"引用位"置0，并把这个页面移至队尾，把它看做一个新调入的页，再给一次机会。特殊的情况如，内存中的页面都被访问过，即它们的"引用位"均为1，那么，第一遍检查将所有页面的"引用位"清0，第二遍找出队首，并把此页面淘汰，此时，SCR退化位FIFO

  简而言之，将FIFO队列的每个页面添加一个引用位，循环找**较早进入并且较长时间未被使用**的页面，将其淘汰。

  

- **时钟页面替换**算法(Clock policy replacement，Clock)

  如果利用标准队列机制，SCR算法可能产生频繁的出队和入队，实现代价较高，因此可采用循环队列来改进它。

  实现要点：

  ```
  1）一个页面首次装入内存时，其"引用位"置1
  
  2）内存中的任何一个页面被访问时，其"引用位"置1
  
  3）淘汰页面时，存储管理从指针当前指向的页面开始扫描循环队列，把所遇到的"引用位"是1的页面的"引用位"清0，
     并跳过这个页面；把所遇到的"引用位"是0的页面淘汰，指针推进一步
     
  4）扫描循环队列时，如果遇到所有页面的"引用位"均为1，指针就会环绕整个循环队列一圈，把 碰到的所有页面的"引
     用位"清0；指针停在起始位置，并淘汰这一页面，然后指针推进一步
  
  ```

  ![1655125347557](./assets/1655125347557.png)

  需要注意的是，找到淘汰目标后，是将其替换成需要调入的页面。

  **进一步优化**：

  淘汰页面时，如果此页面已被修改过，必须将它重新写回磁盘，此时将其淘汰的开销比较大，因此尽可能找未被修改过的页面，并将其淘汰。

  把页表项的"引用位"和"修改位"结合起来使用，可以改进Clock算法，页面共组合成4种情况：

  ````
  - 最近未被引用，未被修改(r=0, m=1)
  - 最近被引用，未被修改(r=1, m=0)
  - 最近未被引用，但被修改过(r=0, m=1)
  - 最近被引用，也被修改过(r=1, m=1)
  ````

  改进过的Clock算法：

  ```
  1) 从指针当前位置开始扫描循环队列，扫描过程中不改变"引用位"，把遇到的第一个(r=0,m=0)的页面淘汰
  2) 如果1）失败，再次从原位置开始，查找第一个(r=0,m=1)的页面，将其淘汰，在扫描过程中将指针所经过的页面的"引用位"r置0
  3) 如果2）失败，指针再次回到原来位置，由于此前所有页面的"引用位"r均为0，下次再转向1）或2）必定能找到一个可淘汰的页面
  ```

  **例子：页面调入顺序：2，3，2，1，5，2，4，5，3，2，5，2；分配给程序3个页框。**

  ![1655126509748](./assets/1655126509748.png)

  

  

  

### 8、局部页面替换算法

当某个进程的发生缺页时，并且系统不允许通过缩小其他进程的驻留页面集来解决问题，此时只能对这个进程的驻留页面集进行调整。

- **局部最佳页面替换算法**(local Minimum replacement，MIN)

  与全局最佳替换算法类似，需要预知程序的页面引用串(该进程的页面调用顺序),再根据进程行为改变驻留页面数量。实现思想如下：

  进程在时刻t访问某页面，如果此页面不在内存中将导致一次缺页，把此页面装入一个空闲页框。无论发生缺页与否，算法在每一步都要考虑引用串，如果此页面在时间间隔$(t, t + \tau)$内未被再次引用，那么就移出；否则，此页面被保留在进程的驻留集中，直到再次被引用。($\tau$是一个系统常量，间隔$(t, t+\tau)$称为滑动窗口，窗口大小为$\tau + 1$)

  例如，进程页面引用串为：

  ![1655033206255](./assets/1655033206255.png)

  在时刻t = 0，P4已被引用

  ![1655033255697](./assets/1655033255697.png)

  ![1655034484797](./assets/1655034484797.png)

  

- **工作集模型和工作集置换算法**(Working Set replacement，WS)

  工作集模型用来对局部最佳页面替换算法进行模拟实现，也是用滑动窗口概念，但并不向前查看页面引用串，而是基于程序局部性原理向后看，在任何给定时刻，一个进程不就的将来所需内存页框数可通过考查最近时间内的内存需求做出估计

  

  进程工作集指在某一段时间间隔内进程运行所需访问的页面集合，用$W(t, \Delta)$表示在时刻$t-\Delta$到时刻$t$之间所访问的页面集合，它就是进程在时刻$t$的工作集，变量$\Delta$为工作集窗口尺寸

  ![1655035090008](./assets/1655035090008.png)

  ![1655035106388](./assets/1655035106388.png)

  ![1655035177808](./assets/1655035177808.png)

  工作集是程序局部性的近似表示，可以通过它来确定驻留集大小

  - 监视每个进程工作集，只有属于工作集的页面才能驻留在内存
  - 定期从进程驻留集中删去那些不在工作集中的页面
  - 仅当一个进程的工作集在内存时，进程才能执行。

- **模拟工作集替换算法**

  工作集策略在现实中监督驻留页面变化的开销很大，而且也很难估算一个合适的窗口$\Delta$的大小，为此介绍一种模拟工作集替换算法：

  为每个页面设置引用位及关联的时间戳，通过超时中断，至少每隔若干条指
  令就周期性地检查引用位及时间截,当发现引用位为1时，就将其置0 并把这次改变的时间作为时间戳记录下来。每当发现引用位为0时,通过系统当前时间诚去时间截的时间，计算出从上次使用以来末被再次访问的时间量,记作（0f。L_0f 值会随着每次超时中渐的处理而不渐增加，除非页面在此期间被再次引用，导致其引用位为 1。把t0ff 与系统时间參数1max 相比.若(off>tmax .就把页面从工作集中移出.释放相成页面并回收此页框。

  

- **缺页频率替换算法**(Page Fault Frequency replacement)

  这种算法根据连续的缺页之间的时间间隔来对缺页频率进行测量，每次缺页时
  利用测量时间调整进程工作集尺寸。其规则是：如果本次缺页与前次缺页之间的时间问隔超过临界值$\tau$，那么，在这个时问间隔内未引用的所有页面都被移出工作集。这就能保证进程工作集不会过分地扩大，与工作集模型相比,实现效率高，具在发生缺页异常时才调数页面,而不是每次引用时都需要调整。

  ![1655036417838](./assets/1655036417838.png)

  

## 三、请求分段式虚拟存储管理

## 四、请求段页式虚拟存储管理

段式和分页的优缺点分析及相互结合

### 1、基本原理

## 五、小结

![1655037257758](./assets/1655037257758.png)

![1655037275137](./assets/1655037275137.png)

## 六、实例分析

## 1、Linux虚拟存储管理

## 2、Intel的Pentium

## 七、参考链接

```
https://blog.csdn.net/shuxnhs/article/details/80956155
```







